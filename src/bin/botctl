#!/usr/bin/env zsh
# Sociobot Monitor and Auto-Restart Script
# Monitors Sociobot instances and restarts them when needed

# set -x

BOTS=(test-agent) # Add your bot names here
BOT_SCRIPT="src/sociobot.js"

BOT_DIR=~/sca/sociobot
PIDFILE="/tmp/botctl.pid"
MAX_LOAD_THRESHOLD=15
EMERGENCY_LOAD_THRESHOLD=30
HIGH_LOAD_COUNT=0
MAX_HIGH_LOAD_COUNT=9
MONITORING=true

# Log command invocation
logger -p user.info "sociobot: Command invoked: $0 $*"

# Change to bot directory
cd "$BOT_DIR" || {
  echo "Error: Cannot change to bot directory: $BOT_DIR" >&2
  logger -p user.error "sociobot: Fatal Error: Failed to change to directory $BOT_DIR"
  exit 1
}



# Handle interruption signals
trap 'die 130 "Interrupted by user (Ctrl+C)"' SIGINT

log_message() {
  [[ "$MONITORING" == true ]] && logger -p user.info "sociobot: $1"
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

get_load_avg() {
  uptime | awk -F'load averages?: ' '{print $2}' | awk '{print $1}'
}

get_load_int() {
  get_load_avg | cut -d . -f 1
}

get_bot_status() {
  declare -r BOT_NAME="$1"

  if pgrep -f "$BOT_SCRIPT $BOT_NAME --debug" > /dev/null; then
    echo debug
  elif pgrep -f "$BOT_SCRIPT $BOT_NAME" > /dev/null; then
    echo running
  else
    echo stopped
  fi
}

is_bot_running() {
  declare -r BOT_NAME="$1"
  local STATUS=$(get_bot_status "$BOT_NAME")
  [[ "$STATUS" != stopped ]]
}

is_monitor_running() {
  if [[ -f "$PIDFILE" ]]; then
    local pid=$(cat "$PIDFILE")
    kill -0 "$pid" 2>/dev/null
  else
    false
  fi
}

stop_monitor() {
  if is_monitor_running; then
    local pid=$(cat "$PIDFILE")
    log_message "ðŸ›‘ Stopping existing monitor (PID $pid)"
    kill "$pid" 2>/dev/null || true
    sleep 2

    if kill -0 "$pid" 2>/dev/null; then
      log_message "âš ï¸  Monitor still running, force killing..."
      kill -9 "$pid" 2>/dev/null || true
    fi

    rm -f "$PIDFILE"
    log_message "âœ… Monitor stopped"
  fi
}

is_valid_bot() {
  local BOT_NAME="$1"
  [[ ${BOTS[(ie)$BOT_NAME]} -le ${#BOTS} ]]
}

start_single_bot() {
  declare -r BOT_NAME="$1"
  local DEBUG_FLAG="$2"

  if is_bot_running "$BOT_NAME"; then
    log_message "âœ… $BOT_NAME bot already running"
    return 0
  fi

  declare -r LOG_FILE="data/logs/${BOT_NAME}-bot.log"

  # Start with clean environment to prevent ZDS_AI_AGENT_* variable leakage
  # Only pass through essential system variables
  if [[ "$DEBUG_FLAG" == --debug ]]; then
    log_message "ðŸ› Starting $BOT_NAME bot in DEBUG mode"
    env -i PATH="$PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" \
      nohup node "$BOT_SCRIPT" "$BOT_NAME" --debug > "$LOG_FILE" 2>&1 &
  else
    env -i PATH="$PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" \
      nohup node "$BOT_SCRIPT" "$BOT_NAME" > "$LOG_FILE" 2>&1 &
  fi

  sleep 3

  if is_bot_running "$BOT_NAME"; then
    log_message "âœ… $BOT_NAME bot started successfully"
    return 0
  else
    log_message "âŒ Failed to start $BOT_NAME bot"
    return 1
  fi
}

stop_single_bot() {
  declare -r BOT_NAME="$1"

  if ! is_bot_running "$BOT_NAME"; then
    log_message "âœ… $BOT_NAME bot already stopped"
    return 0
  fi

  log_message "ðŸ›‘ Stopping $BOT_NAME bot..."
  pkill -f "$BOT_SCRIPT $BOT_NAME" 2>/dev/null || true
  sleep 2

  if is_bot_running "$BOT_NAME"; then
    log_message "âš ï¸  $BOT_NAME bot still running, force killing..."
    pkill -9 -f "$BOT_SCRIPT $BOT_NAME" 2>/dev/null || true
    sleep 1
  fi

  if ! is_bot_running "$BOT_NAME"; then
    log_message "âœ… $BOT_NAME bot stopped"
    return 0
  else
    log_message "âŒ Failed to stop $BOT_NAME bot"
    return 1
  fi
}

check_and_restart_bot() {
  declare -r BOT_NAME="$1"

  # Check if bot process is running
  if ! is_bot_running "$BOT_NAME"; then
    # Check system load before restarting
    if [ "$(get_load_int)" -gt "$MAX_LOAD_THRESHOLD" ]; then
      HIGH_LOAD_COUNT=$((HIGH_LOAD_COUNT + 1))
      log_message "ðŸš« $BOT_NAME bot down but load too high ($(get_load_avg) > $MAX_LOAD_THRESHOLD) -- skipping restart (count: $HIGH_LOAD_COUNT/$MAX_HIGH_LOAD_COUNT)"

      if [ "$HIGH_LOAD_COUNT" -ge "$MAX_HIGH_LOAD_COUNT" ]; then
        die 1 "âŒ System load too high for too long - exiting monitor"
      fi

      sleep 27
      return
    else
      # Reset counter on normal load
      HIGH_LOAD_COUNT=0
    fi

    log_message "âš ï¸  $BOT_NAME bot not running - restarting..."
    start_single_bot "$BOT_NAME"
  else
    log_message "âœ… $BOT_NAME bot running normally"
  fi
}

restart_all_bots() {
  # Kill any existing bots first
  stop_all_bots
  start_all_bots
}

start_all_bots() {
  declare BOT

  log_message "ðŸš€ Starting ${#BOTS[@]} Discord bots..."

  # Start all bots
  for BOT in "${BOTS[@]}"; do
    start_single_bot "$BOT"
    sleep 5 # FIXME: don't sleep after last bot startup?
  done

  log_message "ðŸŽ¯ ${#BOTS[@]} bots startup complete"
}

stop_all_bots() {
  log_message "ðŸ›‘ Stopping all Discord bots..."

  # Kill all bot processes
  pkill -f "$BOT_SCRIPT" 2>/dev/null || true
  sleep 2

  # Verify they're stopped
  if pgrep -f "$BOT_SCRIPT" > /dev/null; then
    log_message "âš ï¸  Some bots still running, force killing..."
    pkill -9 -f "$BOT_SCRIPT" 2>/dev/null || true
  fi

  log_message "âœ… All bots stopped"
}

show_status() {
  declare BOT

  echo "ðŸ“Š Bot Status Report"
  echo "==================="
  echo "ðŸ“ˆ System Load: $(get_load_avg)"
  echo

  if is_monitor_running; then
    echo "ðŸ” Monitor: RUNNING (PID $(cat "$PIDFILE"))"
  else
    echo "âŒ Monitor: STOPPED"
  fi
  echo

  for BOT in "${BOTS[@]}"; do
    local STATUS=$(get_bot_status "$BOT")
    case "$STATUS" in
      debug)
        echo "ðŸ› $BOT bot: RUNNING (DEBUG MODE)"
        ;;
      running)
        echo "âœ… $BOT bot: RUNNING"
        ;;
      stopped)
        echo "âŒ $BOT bot: STOPPED"
        ;;
    esac
  done
}

monitor_loop() {
  if is_monitor_running; then
    die 1 "âŒ Monitor already running (PID $(cat "$PIDFILE"))"
  fi

  MONITORING=true
  echo $$ > "$PIDFILE"
  trap 'rm -f "$PIDFILE"; die 0 "Monitor stopped"' EXIT

  log_message ===============================
  log_message "NEW MONITOR SESSION STARTED, PID $$"
  log_message "ðŸ” Starting continuous monitoring of ${#BOTS[@]} bots..."

  while true; do
    log_message "ðŸ“Š System load: $(get_load_avg)"

    # Check system load first - emergency shutdown if too high
    if [ "$(get_load_int)" -gt "$EMERGENCY_LOAD_THRESHOLD" ]; then
      log_message "ðŸš¨ EMERGENCY: Load extremely high ($(get_load_avg) > $EMERGENCY_LOAD_THRESHOLD) -- killing all bots and exiting"
      stop_all_bots
      die 2 "System load too high"
    fi

    # Check each bot
    for BOT in "${BOTS[@]}"; do
      check_and_restart_bot "$BOT"
    done

    # Wait 30 seconds before next check
    sleep 30
  done
}

start_monitor() {
  if [[ "$1" != --foreground && "$1" != -fg ]]; then
    nohup botctl monitor --foreground > /dev/null 2>&1 &
    echo "ðŸ” Monitor started in background (PID $!)"
    exit 0
  fi
  monitor_loop
}

die() {
  declare -r EXIT_CODE="$1"
  declare -r MESSAGE="$2"
  log_message "ðŸ’€ dying with exit code $EXIT_CODE: $MESSAGE"
  log_message ===============================
  exit $EXIT_CODE
}

# Handle script arguments
case "${1:-help}" in
  start|run)
    if [[ -n "$2" ]]; then
      # Parse arguments to separate --debug flag from bot names
      local DEBUG_FLAG=""
      local BOT_NAMES=()

      shift  # Remove command name
      for arg in "$@"; do
        if [[ "$arg" == --debug ]]; then
          DEBUG_FLAG=--debug
        else
          BOT_NAMES+=("$arg")
        fi
      done

      if [[ ${#BOT_NAMES[@]} -eq 0 ]]; then
        echo "âŒ Error: No bot names specified" >&2
        echo "Valid bots: ${BOTS[*]}" >&2
        exit 1
      fi

      # Start each bot
      for BOT_NAME in "${BOT_NAMES[@]}"; do
        if is_valid_bot "$BOT_NAME"; then
          start_single_bot "$BOT_NAME" "$DEBUG_FLAG"
        else
          echo "âŒ Error: '$BOT_NAME' is not a valid bot name" >&2
          echo "Valid bots: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      start_all_bots
    fi
    ;;
  stop|kill)
    if [[ -n "$2" ]]; then
      shift  # Remove command name
      for BOT_NAME in "$@"; do
        if is_valid_bot "$BOT_NAME"; then
          stop_single_bot "$BOT_NAME"
        else
          echo "âŒ Error: '$BOT_NAME' is not a valid bot name" >&2
          echo "Valid bots: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      stop_monitor
      stop_all_bots
      show_status
    fi
    ;;
  restart)
    if [[ -n "$2" ]]; then
      # Parse arguments to separate --debug flag from bot names
      local DEBUG_FLAG=""
      local BOT_NAMES=()

      shift  # Remove command name
      for arg in "$@"; do
        if [[ "$arg" == --debug ]]; then
          DEBUG_FLAG=--debug
        else
          BOT_NAMES+=("$arg")
        fi
      done

      # FIXME: support restart_all_bots with --debug
      if [[ ${#BOT_NAMES[@]} -eq 0 ]]; then
        echo "âŒ Error: No bot names specified" >&2
        echo "Valid bots: ${BOTS[*]}" >&2
        exit 1
      fi

      # Restart each bot
      for BOT_NAME in "${BOT_NAMES[@]}"; do
        if is_valid_bot "$BOT_NAME"; then
          stop_single_bot "$BOT_NAME"
          start_single_bot "$BOT_NAME" "$DEBUG_FLAG"
        else
          echo "âŒ Error: '$BOT_NAME' is not a valid bot name" >&2
          echo "Valid bots: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      restart_all_bots
    fi
    ;;
  status|st)
    show_status
    ;;
  tail)
    # tail is an alias for logs -f (follow mode)
    if [[ -n "$2" ]]; then
      set -- "logs" "$2" "-f"
    else
      echo "âŒ Error: tail command requires a bot name" >&2
      echo "Usage: $0 tail <bot_name>" >&2
      echo "Valid bots: ${BOTS[*]}" >&2
      exit 1
    fi
    ;& # fall through to logs case
  logs|log)
    if [[ -n "$2" ]]; then
      # Parse arguments: detect bot-name and -f flag
      local BOT_NAME FOLLOW_FLAG

      shift  # Remove command name
      for arg in "$@"; do
        if [[ "$arg" == -f ]]; then
          FOLLOW_FLAG=-f
        else
          BOT_NAME="$arg"
        fi
      done

      if [[ -n "$BOT_NAME" ]]; then
        # Construct log file path and execute tail
        local LOG_FILE="$BOT_DIR/data/logs/${BOT_NAME}-bot.log"
        tail -n 55 $FOLLOW_FLAG "$LOG_FILE"
      fi
    else
      # Existing behavior: show botctl system logs
      /usr/bin/log show --predicate 'process == "logger" AND eventMessage CONTAINS "sociobot:"' \
          --info --debug --last 8h --style compact \
        | sed 's/ logger\[[^]]*\] sociobot: //'
    fi
    ;;
  monitor|mon)
    start_monitor "$2"
    ;;
  restart-monitor|rmon)
    stop_monitor
    restart_all_bots
    start_monitor "$2"
    ;;
  *)
    HELP_WIDTH=42
    echo "Usage: $0 <command> [--debug] [bot_name...]"
    echo
    echo These commands run once and exit:
    printf "  %-${HELP_WIDTH}s - %s\n" "start (run) [--debug] [bot_name...]" "Start all bots or specific bot(s)"
    printf "  %-${HELP_WIDTH}s - %s\n" "stop (kill) [bot_name...]" "Stop monitor and all bots, or specific bot(s)"
    printf "  %-${HELP_WIDTH}s - %s\n" "restart [--debug] [bot_name...]" "Restart all bots or specific bot(s)"
    printf "  %-${HELP_WIDTH}s - %s\n" "status (st)" "Show bot and monitor status"
    printf "  %-${HELP_WIDTH}s - %s\n" "logs (log) [<bot-name> [-f]]" "Show logs (system or bot-name's log)"
    printf "  %-${HELP_WIDTH}s   %s\n" "" "[-f] follow bot log until interrupted"
    printf "  %-${HELP_WIDTH}s - %s\n" "tail <bot-name>" "Follow bot-name's log (alias for logs -f)"
    printf "  %-${HELP_WIDTH}s - %s\n" "help" "Show this help message"
    echo
    echo These commands run continuously until interrupted:
    printf "  %-${HELP_WIDTH}s - %s\n" "monitor (mon) [-fg]" "Monitor bots (background by default, -fg for foreground)"
    printf "  %-${HELP_WIDTH}s - %s\n" "restart-monitor (rmon) [-fg]" "Stop monitor, restart bots, start new monitor"
    echo
    echo Options:
    printf "  %-${HELP_WIDTH}s - %s\n" "--debug" "Enable verbose debug logging (applies to all bots)"
    echo
    echo "Valid bot names: ${BOTS[*]}"
    echo
    echo Examples:
    echo "  $0 start <bot>                 # Start single bot"
    echo "  $0 start <bot1> <bot2>         # Start multiple bots"
    echo "  $0 start --debug <bot1> <bot2> # Start multiple bots with debug logging"
    echo "  $0 stop <bot1> <bot2>          # Stop multiple bots"
    echo "  $0 restart --debug <bot>       # Restart bot with debug logging"
    exit 1
    ;;
esac
