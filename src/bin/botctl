#!/usr/bin/env zsh
# Sociobot/mailbot monitor and auto-restart script
# Monitors *bot instances and restarts them when needed

# set -x

ME=$(basename "$0")

# Check for version option
if [[ "$1" == --version || "$1" == -v ]]; then
  # Find package.json by resolving the script's location
  SCRIPT_PATH="${0:A}"
  PACKAGE_DIR="${SCRIPT_PATH:h:h:h}"
  if [[ -s "$PACKAGE_DIR/package.json" ]]; then
    jq -r '.version' "$PACKAGE_DIR/package.json"
  else
    echo ‚ùå Error: Cannot find package.json >&2
    exit 1
  fi
  exit 0
fi

# Check that ZDS_AI_HOST_ID is set
if [[ -z "$ZDS_AI_HOST_ID" ]]; then
  echo ‚ùå Error: ZDS_AI_HOST_ID environment variable is not set >&2
  echo This variable identifies which host this botctl instance is running on. >&2
  exit 1
fi

# Get all agents and filter to those with sociobot or email configuration AND matching installed_host_id
ALL_AGENTS=($(zai lc))
SOCIOBOT_BOTS=()
MAILBOT_BOTS=()
for agent in "${ALL_AGENTS[@]}"; do
  config_file=~${agent}/.zds-ai/config.zds.yml

  # Skip if no config file
  [[ ! -s "$config_file" ]] && continue

  # Extract installed_host_id from config
  installed_host_id=$(yq eval '.installed_host_id // ""' "$config_file" 2>/dev/null)

  # Skip if no installed_host_id field or doesn't match ZDS_AI_HOST_ID
  [[ -z "$installed_host_id" ]] && continue
  [[ "$installed_host_id" != "$ZDS_AI_HOST_ID" ]] && continue

  # Check for sociobot section
  if grep -q '^sociobot:' "$config_file" 2>/dev/null; then
    SOCIOBOT_BOTS+=($agent)
  fi

  # Check for email section
  if grep -q '^email:' "$config_file" 2>/dev/null; then
    MAILBOT_BOTS+=($agent)
  fi
done

# Maintain BOTS for backwards compatibility (union of both)
BOTS=("${SOCIOBOT_BOTS[@]}" "${MAILBOT_BOTS[@]}")
PIDFILE="/tmp/botctl.pid"
MAX_LOAD_THRESHOLD=25
EMERGENCY_LOAD_THRESHOLD=40
HIGH_LOAD_COUNT=0
MAX_HIGH_LOAD_COUNT=9
MONITORING=true

# Log command invocation
logger -p user.info "sociobot: Command invoked: $ME $*"

# Handle interruption signals
trap 'die 130 "Interrupted by user (Ctrl+C)"' SIGINT

log_message() {
  [[ "$MONITORING" == true ]] && logger -p user.info "sociobot: $1"
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

get_load_avg() {
  uptime | awk -F'load averages?: ' '{print $2}' | awk '{print $1}' | tr -d ,
}

get_load_int() {
  get_load_avg | cut -d . -f 1
}

bot_needs_sudo() {
  # Check if bot needs sudo (matches logic from _zai_helper_agent_needs_sudo)
  # Usage: bot_needs_sudo <bot_name>
  # Returns: 0 (true) if bot needs sudo, 1 (false) otherwise
  local bot_name="$1"

  # Already $USERNAME? sudo not needed.
  [[ "$bot_name" == "$USERNAME" ]] && return 1

  # Bot handle is "bot"? sudo not needed.
  [[ "$bot_name" == bot ]] && return 1

  # No user account? sudo not needed.
  id "$bot_name" &>/dev/null || return 1

  # Bot needs sudo if ~<bot>/.zshrc is owned by bot user account.
  local zshrc_file=~${bot_name}/.zshrc
  [[ ! -f "$zshrc_file" ]] && return 1

  # Get the owner of the .zshrc file
  local file_owner
  if [[ "$(uname)" == Darwin ]]; then
    # macOS: use stat -f
    file_owner=$(stat -f '%Su' "$zshrc_file" 2>/dev/null)
  else
    # Linux: use stat -c
    file_owner=$(stat -c '%U' "$zshrc_file" 2>/dev/null)
  fi

  # Return true (0) if file owner matches bot name
  [[ "$file_owner" == "$bot_name" ]]
}

get_bot_status() {
  declare -r BOT_NAME="$1"

  if pgrep -f "sociobot $BOT_NAME --debug" > /dev/null; then
    echo debug
  elif pgrep -f "sociobot $BOT_NAME" > /dev/null; then
    echo running
  else
    echo stopped
  fi
}

get_mailbot_status() {
  declare -r BOT_NAME="$1"

  # Find all mailbot processes and check their environment variables
  for pid in $(pgrep -f mailbot 2>/dev/null); do
    # Get process environment (platform-specific)
    if [[ "$(uname)" == Darwin ]]; then
      # macOS: use ps eww
      ps eww -p "$pid" 2>/dev/null | tr ' ' '\n' | grep -q "ZDS_AI_AGENT_HANDLE=$BOT_NAME" || continue
    else
      # Linux: read /proc/<pid>/environ
      [[ -f "/proc/$pid/environ" ]] || continue
      # Use sudo to read environ when running as different user (processes run as different users)
      if bot_needs_sudo "$BOT_NAME"; then
        sudo -u "$BOT_NAME" cat /proc/$pid/environ 2>/dev/null | tr '\0' '\n' | grep -q "ZDS_AI_AGENT_HANDLE=$BOT_NAME" || continue
      else
        [[ -r "/proc/$pid/environ" ]] || continue
        tr '\0' '\n' < "/proc/$pid/environ" | grep -q "ZDS_AI_AGENT_HANDLE=$BOT_NAME" || continue
      fi
    fi

    # Found matching process - check if running in debug mode
    ps -p "$pid" -o args= 2>/dev/null | grep -q -- --debug && echo debug || echo running
    return
  done

  echo stopped
}

is_bot_running() {
  declare -r BOT_NAME="$1"
  local STATUS=$(get_bot_status "$BOT_NAME")
  [[ "$STATUS" != stopped ]]
}

is_mailbot_running() {
  declare -r BOT_NAME="$1"
  local STATUS=$(get_mailbot_status "$BOT_NAME")
  [[ "$STATUS" != stopped ]]
}

is_monitor_running() {
  if [[ -f "$PIDFILE" ]]; then
    local pid=$(cat "$PIDFILE")
    kill -0 "$pid" 2>/dev/null
  else
    false
  fi
}

stop_monitor() {
  if is_monitor_running; then
    local pid=$(cat "$PIDFILE")
    log_message "üõë Stopping existing monitor (PID $pid)"
    kill "$pid" 2>/dev/null || true
    sleep 2

    if kill -0 "$pid" 2>/dev/null; then
      log_message "‚ö†Ô∏è  Monitor still running, force killing..."
      kill -9 "$pid" 2>/dev/null || true
    fi

    rm -f "$PIDFILE"
    log_message "‚úÖ Monitor stopped"
  fi
}

is_valid_bot() {
  local BOT_NAME="$1"
  [[ ${BOTS[(ie)$BOT_NAME]} -le ${#BOTS} ]]
}

start_single_bot() {
  declare -r BOT_NAME="$1"
  local DEBUG_FLAG="$2"

  if is_bot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME bot already running"
    return 0
  fi

  local zai_output=$(zai pv "$BOT_NAME")
  declare -r LOGS_DIR=$(grep '^ZDS_AI_AGENT_LOGS_DIR=' <<< "$zai_output" | cut -d= -f2-)
  declare -r LOG_FILE="${LOGS_DIR}/sociobot.log"
  declare -r CONFIG_FILE=$(grep '^ZDS_AI_AGENT_CONFIG_FILE=' <<< "$zai_output" | cut -d= -f2-)

  # Start with clean environment to prevent ZDS_AI_AGENT_* variable leakage
  # Only pass through essential system and API key variables
  # Run as agent user when in container to allow writing to agent's log directory

  if [[ "$DEBUG_FLAG" == --debug ]]; then
    log_message "üêõ Starting $BOT_NAME bot in DEBUG mode"
  fi

  # Determine if we need to sudo (when running as different user than target bot)
  if bot_needs_sudo "$BOT_NAME"; then
    # Run as agent user via sudo, passing through API keys and system vars
    local AGENT_HOME=~"$BOT_NAME"
    cd "$AGENT_HOME"
    sudo -u "$BOT_NAME" zsh -c "env -i \
      PATH=\"$PATH\" \
      HOME=\"$AGENT_HOME\" \
      LANG=\"${LANG:-en_US.UTF-8}\" \
      ${TZ:+TZ=\"$TZ\"} \
      ANTHROPIC_API_KEY=\"$ANTHROPIC_API_KEY\" \
      ARLIAI_API_KEY=\"$ARLIAI_API_KEY\" \
      CLAUDE_CODE_OAUTH_TOKEN=\"$CLAUDE_CODE_OAUTH_TOKEN\" \
      GITHUB_PERSONAL_ACCESS_TOKEN=\"$GITHUB_PERSONAL_ACCESS_TOKEN\" \
      GITHUB_TOKEN=\"$GITHUB_TOKEN\" \
      GROK_API_KEY=\"$GROK_API_KEY\" \
      MISTRAL_API_KEY=\"$MISTRAL_API_KEY\" \
      MORPH_API_KEY=\"$MORPH_API_KEY\" \
      NANOGPT_API_KEY=\"$NANOGPT_API_KEY\" \
      OLLAMA_API_KEY=\"$OLLAMA_API_KEY\" \
      OLLAMA_HOST=\"$OLLAMA_HOST\" \
      OPENAI_API_KEY=\"$OPENAI_API_KEY\" \
      OPENROUTER_API_KEY=\"$OPENROUTER_API_KEY\" \
      PLANO_API_KEY=\"$PLANO_API_KEY\" \
      SYNTHETIC_API_KEY=\"$SYNTHETIC_API_KEY\" \
      VENICE_API_KEY=\"$VENICE_API_KEY\" \
      ZDS_AI_AGENT_CONFIG_FILE=\"$CONFIG_FILE\" \
      ZDS_AI_CLIENT_ID=\"$ZDS_AI_CLIENT_ID\" \
      ZDS_AI_HOST_ID=\"$ZDS_AI_HOST_ID\" \
      ZDS_AI_IMAGE_ENDPOINT=\"$ZDS_AI_IMAGE_ENDPOINT\" \
      ZDS_AI_ROOT=\"$ZDS_AI_ROOT\" \
      ZDS_AI_TTS_ENDPOINT=\"$ZDS_AI_TTS_ENDPOINT\" \
      ZDS_AI_TTS_USER=\"$ZDS_AI_TTS_USER\" \
      ZDS_AI_TTS_PASS=\"$ZDS_AI_TTS_PASS\" \
      nohup sociobot \"$BOT_NAME\" $DEBUG_FLAG >> \"$LOG_FILE\" 2>&1 &"
  else
    # On host or shared user: run as current user
    cd "$HOME"
    env -i PATH="$PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" \
      ${TZ:+TZ="$TZ"} \
      CLAUDE_CODE_OAUTH_TOKEN="$CLAUDE_CODE_OAUTH_TOKEN" \
      OLLAMA_HOST="$OLLAMA_HOST" \
      ZDS_AI_AGENT_CONFIG_FILE="$CONFIG_FILE" \
      ZDS_AI_TTS_ENDPOINT="$ZDS_AI_TTS_ENDPOINT" \
      ZDS_AI_TTS_USER="$ZDS_AI_TTS_USER" \
      ZDS_AI_TTS_PASS="$ZDS_AI_TTS_PASS" \
      nohup sociobot "$BOT_NAME" $DEBUG_FLAG >> "$LOG_FILE" 2>&1 &
  fi

  sleep 1

  if is_bot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME bot started successfully"
    return 0
  else
    log_message "‚ùå Failed to start $BOT_NAME bot"
    return 1
  fi
}

stop_single_bot() {
  declare -r BOT_NAME="$1"

  if ! is_bot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME bot already stopped"
    return 0
  fi

  log_message "üõë Stopping $BOT_NAME bot..."

  # Use sudo when running as different user to kill processes owned by agent user
  if bot_needs_sudo "$BOT_NAME"; then
    sudo -u "$BOT_NAME" pkill -f "sociobot $BOT_NAME" 2>/dev/null || true
  else
    pkill -f "sociobot $BOT_NAME" 2>/dev/null || true
  fi
  sleep 2

  if is_bot_running "$BOT_NAME"; then
    log_message "‚ö†Ô∏è  $BOT_NAME bot still running, force killing..."
    if bot_needs_sudo "$BOT_NAME"; then
      sudo -u "$BOT_NAME" pkill -9 -f "sociobot $BOT_NAME" 2>/dev/null || true
    else
      pkill -9 -f "sociobot $BOT_NAME" 2>/dev/null || true
    fi
    sleep 1
  fi

  if ! is_bot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME bot stopped"
    return 0
  else
    log_message "‚ùå Failed to stop $BOT_NAME bot"
    return 1
  fi
}

start_single_mailbot() {
  declare -r BOT_NAME="$1"
  local DEBUG_FLAG="$2"

  if is_mailbot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME mailbot already running"
    return 0
  fi

  local zai_output=$(zai pv "$BOT_NAME")
  declare -r LOGS_DIR=$(grep '^ZDS_AI_AGENT_LOGS_DIR=' <<< "$zai_output" | cut -d= -f2-)
  declare -r LOG_FILE="${LOGS_DIR}/mailbot.log"
  declare -r CONFIG_FILE=$(grep '^ZDS_AI_AGENT_CONFIG_FILE=' <<< "$zai_output" | cut -d= -f2-)
  declare -r BOT_NAME_VAR=$(grep '^ZDS_AI_AGENT_HANDLE=' <<< "$zai_output" | cut -d= -f2-)

  if [[ "$DEBUG_FLAG" == --debug ]]; then
    log_message "üêõ Starting $BOT_NAME mailbot in DEBUG mode"
  fi

  # Determine if we need to sudo (when running as different user than target bot)
  if bot_needs_sudo "$BOT_NAME"; then
    # Run as agent user via sudo
    local AGENT_HOME=~"$BOT_NAME"
    cd "$AGENT_HOME"
    sudo -u "$BOT_NAME" zsh -c "env -i \
      PATH=\"$PATH\" \
      HOME=\"$AGENT_HOME\" \
      LANG=\"${LANG:-en_US.UTF-8}\" \
      ${TZ:+TZ=\"$TZ\"} \
      OLLAMA_HOST=\"$OLLAMA_HOST\" \
      ZDS_AI_AGENT_HANDLE=\"$BOT_NAME_VAR\" \
      ZDS_AI_AGENT_CONFIG_FILE=\"$CONFIG_FILE\" \
      ZDS_AI_AGENT_LOGS_DIR=\"$LOGS_DIR\" \
      ZDS_AI_HOST_ID=\"$ZDS_AI_HOST_ID\" \
      nohup mailbot $DEBUG_FLAG >> \"$LOG_FILE\" 2>&1 &"
  else
    # On host or shared user: run as current user
    cd "$HOME"
    env -i PATH="$PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" \
      ${TZ:+TZ="$TZ"} \
      OLLAMA_HOST="$OLLAMA_HOST" \
      ZDS_AI_AGENT_HANDLE="$BOT_NAME_VAR" \
      ZDS_AI_AGENT_CONFIG_FILE="$CONFIG_FILE" \
      ZDS_AI_AGENT_LOGS_DIR="$LOGS_DIR" \
      ZDS_AI_HOST_ID="$ZDS_AI_HOST_ID" \
      nohup mailbot $DEBUG_FLAG >> "$LOG_FILE" 2>&1 &
  fi

  sleep 1

  if is_mailbot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME mailbot started successfully"
    return 0
  else
    log_message "‚ùå Failed to start $BOT_NAME mailbot"
    return 1
  fi
}

stop_single_mailbot() {
  declare -r BOT_NAME="$1"

  if ! is_mailbot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME mailbot already stopped"
    return 0
  fi

  log_message "üõë Stopping $BOT_NAME mailbot..."

  # Use sudo when running as different user to kill processes owned by agent user
  if bot_needs_sudo "$BOT_NAME"; then
    sudo -u "$BOT_NAME" pkill -f mailbot 2>/dev/null || true
    sleep 1
  else
    pkill -f mailbot 2>/dev/null || true
    sleep 1
  fi

  # Force kill if still running
  if is_mailbot_running "$BOT_NAME"; then
    log_message "‚ö†Ô∏è  Mailbot still running, force killing..."
    if bot_needs_sudo "$BOT_NAME"; then
      sudo -u "$BOT_NAME" pkill -9 -f mailbot 2>/dev/null || true
    else
      pkill -9 -f mailbot 2>/dev/null || true
    fi
    sleep 1
  fi

  if ! is_mailbot_running "$BOT_NAME"; then
    log_message "‚úÖ $BOT_NAME mailbot stopped"
    return 0
  else
    log_message "‚ùå Failed to stop $BOT_NAME mailbot"
    return 1
  fi
}

check_and_restart_bot() {
  declare -r BOT_NAME="$1"

  # Check if bot process is running
  if ! is_bot_running "$BOT_NAME"; then
    # Check system load before restarting
    if [ "$(get_load_int)" -gt "$MAX_LOAD_THRESHOLD" ]; then
      HIGH_LOAD_COUNT=$((HIGH_LOAD_COUNT + 1))
      log_message "üö´ $BOT_NAME bot down but load too high ($(get_load_avg) > $MAX_LOAD_THRESHOLD) -- skipping restart (count: $HIGH_LOAD_COUNT/$MAX_HIGH_LOAD_COUNT)"

      if [ "$HIGH_LOAD_COUNT" -ge "$MAX_HIGH_LOAD_COUNT" ]; then
        die 1 "‚ùå System load too high for too long - exiting monitor"
      fi

      sleep 29
      return
    else
      # Reset counter on normal load
      HIGH_LOAD_COUNT=0
    fi

    log_message "‚ö†Ô∏è  $BOT_NAME bot not running -- restarting..."
    start_single_bot "$BOT_NAME"
  else
    log_message "‚úÖ $BOT_NAME bot running normally"
  fi
}

restart_all_bots() {
  # Kill any existing bots first
  stop_all_bots
  start_all_bots
}

start_all_bots() {
  declare BOT

  local total_bots=$(( ${#SOCIOBOT_BOTS[@]} + ${#MAILBOT_BOTS[@]} ))
  log_message "üöÄ Starting ${total_bots} bots (${#SOCIOBOT_BOTS[@]} Discord, ${#MAILBOT_BOTS[@]} Email)..."

  # Start all sociobots
  for BOT in "${SOCIOBOT_BOTS[@]}"; do
    start_single_bot "$BOT"
    sleep 3
  done

  # Start all mailbots
  for BOT in "${MAILBOT_BOTS[@]}"; do
    start_single_mailbot "$BOT"
    sleep 3
  done

  log_message "üéØ ${total_bots} bots startup complete"
}

stop_all_bots() {
  local total_bots=$(( ${#SOCIOBOT_BOTS[@]} + ${#MAILBOT_BOTS[@]} ))
  log_message "üõë Stopping all bots (${#SOCIOBOT_BOTS[@]} Discord, ${#MAILBOT_BOTS[@]} Email)..."

  # Kill all sociobot processes
  if [[ ${#SOCIOBOT_BOTS[@]} -gt 0 ]]; then
    # Check if we need sudo by checking if any bot needs sudo
    local need_sudo=false
    for BOT in "${SOCIOBOT_BOTS[@]}"; do
      bot_needs_sudo "$BOT" && need_sudo=true && break
    done

    if $need_sudo; then
      for BOT in "${SOCIOBOT_BOTS[@]}"; do
        sudo -u "$BOT" pkill -f "sociobot $BOT" 2>/dev/null || true
      done
    else
      pkill -f "sociobot" 2>/dev/null || true
    fi
  fi

  # Kill all mailbot processes
  if [[ ${#MAILBOT_BOTS[@]} -gt 0 ]]; then
    # Check if we need sudo by checking if any bot needs sudo
    local need_sudo=false
    for BOT in "${MAILBOT_BOTS[@]}"; do
      bot_needs_sudo "$BOT" && need_sudo=true && break
    done

    if $need_sudo; then
      for BOT in "${MAILBOT_BOTS[@]}"; do
        sudo -u "$BOT" pkill -f mailbot 2>/dev/null || true
      done
    else
      pkill -f mailbot 2>/dev/null || true
    fi
  fi

  sleep 2

  # Verify they're stopped and force kill if needed
  if pgrep -f "sociobot" > /dev/null; then
    log_message "‚ö†Ô∏è  Some sociobots still running, force killing..."
    # Check if we need sudo
    local need_sudo=false
    for BOT in "${SOCIOBOT_BOTS[@]}"; do
      bot_needs_sudo "$BOT" && need_sudo=true && break
    done

    if $need_sudo; then
      for BOT in "${SOCIOBOT_BOTS[@]}"; do
        sudo -u "$BOT" pkill -9 -f "sociobot $BOT" 2>/dev/null || true
      done
    else
      pkill -9 -f "sociobot" 2>/dev/null || true
    fi
  fi

  if pgrep -f mailbot > /dev/null; then
    log_message "‚ö†Ô∏è  Some mailbots still running, force killing..."
    # Check if we need sudo
    local need_sudo=false
    for BOT in "${MAILBOT_BOTS[@]}"; do
      bot_needs_sudo "$BOT" && need_sudo=true && break
    done

    if $need_sudo; then
      for BOT in "${MAILBOT_BOTS[@]}"; do
        sudo -u "$BOT" pkill -9 -f mailbot 2>/dev/null || true
      done
    else
      pkill -9 -f mailbot 2>/dev/null || true
    fi
  fi

  log_message "‚úÖ All bots stopped"
}

show_status() {
  declare BOT

  echo üìä Bot Status Report
  echo ====================
  echo üìà System Load: $(get_load_avg)
  echo

  if is_monitor_running; then
    echo "üîç Monitor: RUNNING (PID $(cat "$PIDFILE"))"
  else
    echo ‚ùå Monitor: STOPPED
  fi
  echo

  # Show sociobot status
  if [[ ${#SOCIOBOT_BOTS[@]} -gt 0 ]]; then
    echo "Discord Bots (sociobot):"
    for BOT in "${SOCIOBOT_BOTS[@]}"; do
      local STATUS=$(get_bot_status "$BOT")
      case "$STATUS" in
        debug)
          echo "  üêõ $BOT: RUNNING (DEBUG MODE)"
          ;;
        running)
          echo "  ‚úÖ $BOT: RUNNING"
          ;;
        stopped)
          echo "  ‚ùå $BOT: STOPPED"
          ;;
      esac
    done
    echo
  fi

  # Show mailbot status
  if [[ ${#MAILBOT_BOTS[@]} -gt 0 ]]; then
    echo "Email Bots (mailbot):"
    for BOT in "${MAILBOT_BOTS[@]}"; do
      local STATUS=$(get_mailbot_status "$BOT")
      case "$STATUS" in
        debug)
          echo "  üêõ $BOT: RUNNING (DEBUG MODE)"
          ;;
        running)
          echo "  ‚úÖ $BOT: RUNNING"
          ;;
        stopped)
          echo "  ‚ùå $BOT: STOPPED"
          ;;
        *)
          echo "  ‚ö†Ô∏è  $BOT: UNKNOWN STATUS ($STATUS)"
          ;;
      esac
    done
  fi
}

monitor_loop() {
  if is_monitor_running; then
    die 1 "‚ùå Monitor already running (PID $(cat "$PIDFILE"))"
  fi

  MONITORING=true
  echo $$ > "$PIDFILE"
  trap 'rm -f "$PIDFILE"; die 0 "Monitor stopped"' EXIT

  log_message ===============================
  log_message "NEW MONITOR SESSION STARTED, PID $$"
  log_message "üîç Starting continuous monitoring of ${#BOTS[@]} bots..."

  # Track current date for midnight restart detection
  CURRENT_DATE=$(date +%Y-%m-%d)

  while true; do
    log_message "üìä System load: $(get_load_avg)"

    # Check for date change (after midnight)
    NEW_DATE=$(date +%Y-%m-%d)
    if [[ "$NEW_DATE" != "$CURRENT_DATE" ]]; then
      log_message "Date changed from $CURRENT_DATE to $NEW_DATE -- performing midnight restart of all bots"

      # Capture debug state of all bots before restart
      declare -A BOT_STATES
      for BOT in "${SOCIOBOT_BOTS[@]}"; do
        BOT_STATES[$BOT]=$(get_bot_status "$BOT")
      done
      for BOT in "${MAILBOT_BOTS[@]}"; do
        BOT_STATES[$BOT]=$(get_mailbot_status "$BOT")
      done

      stop_all_bots

      # Restart each bot (debug bots stay in debug mode, others in normal mode)
      for BOT in "${SOCIOBOT_BOTS[@]}"; do
        local STATE="${BOT_STATES[$BOT]}"
        if [[ "$STATE" == debug ]]; then
          log_message "DEBUG: Restarting $BOT bot in DEBUG mode"
          start_single_bot "$BOT" --debug
        else
          log_message "Restarting $BOT bot in NORMAL mode"
          start_single_bot "$BOT"
        fi
        sleep 3
      done

      for BOT in "${MAILBOT_BOTS[@]}"; do
        local STATE="${BOT_STATES[$BOT]}"
        if [[ "$STATE" == debug ]]; then
          log_message "DEBUG: Restarting $BOT mailbot in DEBUG mode"
          start_single_mailbot "$BOT" --debug
        else
          log_message "Restarting $BOT mailbot in NORMAL mode"
          start_single_mailbot "$BOT"
        fi
        sleep 3
      done

      CURRENT_DATE="$NEW_DATE"
      log_message "Midnight restart complete -- resuming normal monitoring"
    fi

    # Check system load first - emergency shutdown if too high
    if [ "$(get_load_int)" -gt "$EMERGENCY_LOAD_THRESHOLD" ]; then
      log_message "üö® EMERGENCY: Load extremely high ($(get_load_avg) > $EMERGENCY_LOAD_THRESHOLD) -- killing all bots and exiting"
      stop_all_bots
      die 2 "System load too high"
    fi

    # Check each bot
    for BOT in "${BOTS[@]}"; do
      check_and_restart_bot "$BOT"
    done

    # Wait 30 seconds before next check
    sleep 30
  done
}

start_monitor() {
  if [[ "$1" != --foreground && "$1" != -fg ]]; then
    nohup botctl monitor --foreground > /dev/null 2>&1 &
    echo "üîç Monitor started in background (PID $!)"
    exit 0
  fi
  monitor_loop
}

die() {
  declare -r EXIT_CODE="$1"
  declare -r MESSAGE="$2"
  log_message "üíÄ dying with exit code $EXIT_CODE: $MESSAGE"
  log_message ===============================
  exit $EXIT_CODE
}

# Handle script arguments
case "${1:-help}" in
  start|run)
    if [[ -n "$2" ]]; then
      # Parse arguments to separate --debug flag from bot names
      local DEBUG_FLAG
      local BOT_NAMES=()

      shift  # Remove command name
      for arg in "$@"; do
        if [[ "$arg" == --debug || "$arg" == debug ]]; then
          DEBUG_FLAG=--debug
        else
          BOT_NAMES+=("$arg")
        fi
      done

      if [[ ${#BOT_NAMES[@]} -eq 0 ]]; then
        echo ‚ùå Error: No agents specified >&2
        echo Valid agents: ${BOTS[*]} >&2
        exit 1
      fi

      # Start each bot (sociobot and/or mailbot)
      for BOT_NAME in "${BOT_NAMES[@]}"; do
        if is_valid_bot "$BOT_NAME"; then
          # Check if bot has sociobot config
          if [[ " ${SOCIOBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            start_single_bot "$BOT_NAME" "$DEBUG_FLAG"
          fi
          # Check if bot has mailbot config
          if [[ " ${MAILBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            start_single_mailbot "$BOT_NAME" "$DEBUG_FLAG"
          fi
        else
          echo "‚ùå Error: '$BOT_NAME' is not a valid bot name" >&2
          echo "Valid bots: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      start_all_bots
    fi
    ;;
  stop|kill)
    if [[ -n "$2" ]]; then
      shift  # Remove command name
      for BOT_NAME in "$@"; do
        if is_valid_bot "$BOT_NAME"; then
          # Check if bot has sociobot config
          if [[ " ${SOCIOBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            stop_single_bot "$BOT_NAME"
          fi
          # Check if bot has mailbot config
          if [[ " ${MAILBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            stop_single_mailbot "$BOT_NAME"
          fi
        else
          echo "‚ùå Error: '$BOT_NAME' is not a valid bot name" >&2
          echo "Valid bots: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      stop_monitor
      stop_all_bots
      show_status
    fi
    ;;

  restart)
    if [[ -n "$2" ]]; then
      # Parse arguments to separate --debug flag from bot names
      local DEBUG_FLAG
      local BOT_NAMES=()

      shift  # Remove command name
      for arg in "$@"; do
        if [[ "$arg" == --debug || "$arg" == debug ]]; then
          DEBUG_FLAG=--debug
        else
          BOT_NAMES+=("$arg")
        fi
      done

      # FIXME: support restart_all_bots with --debug
      if [[ ${#BOT_NAMES[@]} -eq 0 ]]; then
        echo ‚ùå Error: No agents specified >&2
        echo Valid agents: ${BOTS[*]} >&2
        exit 1
      fi

      # Restart each bot (sociobot and/or mailbot)
      for BOT_NAME in "${BOT_NAMES[@]}"; do
        if is_valid_bot "$BOT_NAME"; then
          # Check if bot has sociobot config
          if [[ " ${SOCIOBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            stop_single_bot "$BOT_NAME"
            start_single_bot "$BOT_NAME" "$DEBUG_FLAG"
          fi
          # Check if bot has mailbot config
          if [[ " ${MAILBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
            stop_single_mailbot "$BOT_NAME"
            start_single_mailbot "$BOT_NAME" "$DEBUG_FLAG"
          fi
        else
          echo "‚ùå Error: '$BOT_NAME' is not a valid agent name" >&2
          echo "Valid agents: ${BOTS[*]}" >&2
          exit 1
        fi
      done
    else
      restart_all_bots
    fi
    ;;

  status|st)
    show_status
    ;;

  tail)
    # tail is an alias for logs -f (follow mode)
    if [[ -n "$2" ]]; then
      # Strip -f flag if present (tail always follows)
      if [[ "$2" == "-f" ]]; then
        set -- "logs" "$3" "-f"
      else
        set -- "logs" "$2" "-f"
      fi
    else
      echo ‚ùå Error: tail command requires an agent name >&2
      echo Usage: $ME tail \<agent\> >&2
      echo Valid agents: ${BOTS[*]} >&2
      exit 1
    fi
    ;& # fall through to logs case

  logs|log)
    if [[ -n "$2" ]]; then
      # Parse arguments: detect bot-name and -f flag
      local BOT_NAME FOLLOW_FLAG

      shift  # Remove command name
      for arg in "$@"; do
        [[ "$arg" == -f ]] && FOLLOW_FLAG=-F || BOT_NAME="$arg"
      done

      if [[ -n "$BOT_NAME" ]]; then
        if ! is_valid_bot "$BOT_NAME"; then
          echo "‚ùå Error: '$BOT_NAME' is not a valid agent name" >&2
          echo "Valid agents: ${BOTS[*]}" >&2
          exit 1
        fi

        # Construct log file path based on bot type
        local LOGS_DIR=$(zai pv "$BOT_NAME" | grep '^ZDS_AI_AGENT_LOGS_DIR=' | cut -d= -f2-)
        local LOG_FILES=()

        # Check which bot type(s) this bot has
        if [[ " ${SOCIOBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
          LOG_FILES+=("${LOGS_DIR}/sociobot.log")
        fi

        if [[ " ${MAILBOT_BOTS[@]} " =~ " ${BOT_NAME} " ]]; then
          LOG_FILES+=("${LOGS_DIR}/mailbot.log")
        fi

        # Show logs
        if [[ ${#LOG_FILES[@]} -eq 0 ]]; then
          echo "‚ùå Error: No log files found for agent '$BOT_NAME'" >&2
          exit 1
        elif [[ ${#LOG_FILES[@]} -eq 1 ]]; then
          # Single log file - show it
          tail -n 55 $FOLLOW_FLAG "${LOG_FILES[1]}"
        else
          # Multiple log files - tail can handle them all
          if [[ -n "$FOLLOW_FLAG" ]]; then
            # Follow both logs (tail will show which file each line is from)
            tail -n 55 $FOLLOW_FLAG "${LOG_FILES[@]}"
          else
            # Show both logs sequentially with headers
            for LOG_FILE in "${LOG_FILES[@]}"; do
              echo "=== ${LOG_FILE:t} ==="
              tail -n 55 "$LOG_FILE"
              echo
            done
          fi
        fi
      fi
    else
      # Show botctl system logs (platform-specific)
      if [[ "$(uname)" == Darwin ]]; then
        # macOS: use unified logging system
        /usr/bin/log show --predicate 'process == "logger" AND eventMessage CONTAINS "sociobot:"' \
            --info --debug --last 8h --style compact \
          | sed 's/ logger\[[^]]*\] sociobot: //'
      else
        # Linux: use journalctl or syslog
        if command -v journalctl >/dev/null 2>&1; then
          journalctl --since "8 hours ago" --no-pager | grep "sociobot:"
        elif [[ -f /var/log/syslog ]]; then
          grep "sociobot:" /var/log/syslog | tail -n 100
        elif [[ -f /var/log/messages ]]; then
          grep "sociobot:" /var/log/messages | tail -n 100
        else
          echo ‚ùå Error: Cannot find system logs >&2
          echo "Use '$ME logs <agent>' to view agent-specific logs" >&2
          exit 1
        fi
      fi
    fi
    ;;

  monitor|mon)
    start_monitor "$2"
    ;;

  restart-monitor|rmon)
    stop_monitor
    restart_all_bots
    start_monitor "$2"
    ;;

  *)
    HELP_WIDTH=42
    echo Usage: $ME \<command\> [--debug] [\<agent\> ...]
    echo
    echo These commands run once and exit:
    printf "  %-${HELP_WIDTH}s# %s\n" "start (run) [--debug] [<agent> ...]" "Start all bots or only specified agent(s)' bot(s)"
    printf "  %-${HELP_WIDTH}s# %s\n" "stop (kill) [<agent> ...]" "Stop monitor and all bots, or only specified agent(s)' bot(s)"
    printf "  %-${HELP_WIDTH}s# %s\n" "restart [--debug] [bot_name...]" "Restart all or specific bot(s)"
    printf "  %-${HELP_WIDTH}s# %s\n" "status (st)" "Show bot and monitor status"
    printf "  %-${HELP_WIDTH}s# %s\n" "logs (log) [<agent> [-f]]" "Show logs (system or agent's bot log(s))"
    printf "  %-${HELP_WIDTH}s  %s\n" "" "[-f] follow agent's bot log(s) until interrupted"
    printf "  %-${HELP_WIDTH}s# %s\n" "tail <agent>" "same as above (alias for logs -f)"
    printf "  %-${HELP_WIDTH}s# %s\n" help "Show this help message"
    echo
    echo These commands run continuously until interrupted:
    printf "  %-${HELP_WIDTH}s# %s\n" "monitor (mon) [-fg]" "Monitor bots (background by default, -fg for foreground)"
    printf "  %-${HELP_WIDTH}s# %s\n" "restart-monitor (rmon) [-fg]" "Stop monitor, restart bots, start new monitor"
    echo
    echo Options:
    printf "  %-${HELP_WIDTH}s# %s\n" --debug "Enable verbose debug logging (applies to all bots)"
    echo
    echo Valid agent names: ${BOTS[*]}
    echo
    echo Examples:
    echo "  $ME restart --debug <agent>            # Restart agent's bot(s) with debug logging"
    exit 1
    ;;
esac
